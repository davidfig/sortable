const icons = require('./icons');

/**
 * Options for Sortable
 * @typedef {object} Sortable~DefaultOptions
 * @property {string} [options.name=sortable] dragging is allowed between Sortables with the same name
 * @property {string} [options.dragClass] if set then drag only items with this className under element; otherwise drag all children
 * @property {string} [options.orderClass] use this class to include elements in ordering but not dragging; otherwise all children elements are included in when sorting and ordering
 * @property {boolean} [options.deepSearch] if dragClass and deepSearch then search all descendents of element for dragClass
 * @property {boolean} [options.sort=true] allow sorting within list
 * @property {string} [options.orderId=data-order] for ordered lists, use this data id to figure out sort order
 * @property {boolean} [options.orderIdIsNumber=true] use parseInt on options.sortId to properly sort numbers
 * @property {string} [options.reverseOrder] reverse sort the orderId
 * @property {boolean} [options.alwaysInList=true] place element inside closest related Sortable object; if set to false then the object is removed if dropped outside related sortables
 * @property {object} [options.childrenStyles] styles to apply to children elements of Sortable
 * @property {boolean} [options.useIcons=true] show icons when dragging
 * @property {object} [options.icons] default set of icons
 * @property {string} [options.icons.reorder]
 * @property {string} [options.icons.move]
 * @property {string} [options.icons.copy]
 * @property {string} [options.icons.delete]
 */
module.exports = {
    name: 'sortable',
    sort: true,
    orderId: 'data-order',
    orderIdIsNumber: true,
    threshold: 10,
    alwaysInList: true,
    dragClass: null,
    orderClass: null,
    returnHome: true,
    deepSearch: false,
    dragStyle: {
        boxShadow: '3px 3px 5px rgba(0,0,0,0.25)',
        opacity: 0.85
    },
    childrenStyles: {
        cursor: 'pointer'
    },
    useIcons: true,
    icons
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9vcHRpb25zLmpzIl0sIm5hbWVzIjpbImljb25zIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJuYW1lIiwic29ydCIsIm9yZGVySWQiLCJvcmRlcklkSXNOdW1iZXIiLCJ0aHJlc2hvbGQiLCJhbHdheXNJbkxpc3QiLCJkcmFnQ2xhc3MiLCJvcmRlckNsYXNzIiwicmV0dXJuSG9tZSIsImRlZXBTZWFyY2giLCJkcmFnU3R5bGUiLCJib3hTaGFkb3ciLCJvcGFjaXR5IiwiY2hpbGRyZW5TdHlsZXMiLCJjdXJzb3IiLCJ1c2VJY29ucyJdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsUUFBUUMsUUFBUSxTQUFSLENBQWQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBQyxPQUFPQyxPQUFQLEdBQWlCO0FBQ2JDLFVBQU0sVUFETztBQUViQyxVQUFNLElBRk87QUFHYkMsYUFBUyxZQUhJO0FBSWJDLHFCQUFpQixJQUpKO0FBS2JDLGVBQVcsRUFMRTtBQU1iQyxrQkFBYyxJQU5EO0FBT2JDLGVBQVcsSUFQRTtBQVFiQyxnQkFBWSxJQVJDO0FBU2JDLGdCQUFZLElBVEM7QUFVYkMsZ0JBQVksS0FWQztBQVdiQyxlQUFXO0FBQ1BDLG1CQUFXLDhCQURKO0FBRVBDLGlCQUFTO0FBRkYsS0FYRTtBQWViQyxvQkFBZ0I7QUFDWkMsZ0JBQVE7QUFESSxLQWZIO0FBa0JiQyxjQUFVLElBbEJHO0FBbUJibkI7QUFuQmEsQ0FBakIiLCJmaWxlIjoib3B0aW9ucy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGljb25zID0gcmVxdWlyZSgnLi9pY29ucycpXHJcblxyXG4vKipcclxuICogT3B0aW9ucyBmb3IgU29ydGFibGVcclxuICogQHR5cGVkZWYge29iamVjdH0gU29ydGFibGV+RGVmYXVsdE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLm5hbWU9c29ydGFibGVdIGRyYWdnaW5nIGlzIGFsbG93ZWQgYmV0d2VlbiBTb3J0YWJsZXMgd2l0aCB0aGUgc2FtZSBuYW1lXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5kcmFnQ2xhc3NdIGlmIHNldCB0aGVuIGRyYWcgb25seSBpdGVtcyB3aXRoIHRoaXMgY2xhc3NOYW1lIHVuZGVyIGVsZW1lbnQ7IG90aGVyd2lzZSBkcmFnIGFsbCBjaGlsZHJlblxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbnMub3JkZXJDbGFzc10gdXNlIHRoaXMgY2xhc3MgdG8gaW5jbHVkZSBlbGVtZW50cyBpbiBvcmRlcmluZyBidXQgbm90IGRyYWdnaW5nOyBvdGhlcndpc2UgYWxsIGNoaWxkcmVuIGVsZW1lbnRzIGFyZSBpbmNsdWRlZCBpbiB3aGVuIHNvcnRpbmcgYW5kIG9yZGVyaW5nXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVlcFNlYXJjaF0gaWYgZHJhZ0NsYXNzIGFuZCBkZWVwU2VhcmNoIHRoZW4gc2VhcmNoIGFsbCBkZXNjZW5kZW50cyBvZiBlbGVtZW50IGZvciBkcmFnQ2xhc3NcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3B0aW9ucy5zb3J0PXRydWVdIGFsbG93IHNvcnRpbmcgd2l0aGluIGxpc3RcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLm9yZGVySWQ9ZGF0YS1vcmRlcl0gZm9yIG9yZGVyZWQgbGlzdHMsIHVzZSB0aGlzIGRhdGEgaWQgdG8gZmlndXJlIG91dCBzb3J0IG9yZGVyXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wdGlvbnMub3JkZXJJZElzTnVtYmVyPXRydWVdIHVzZSBwYXJzZUludCBvbiBvcHRpb25zLnNvcnRJZCB0byBwcm9wZXJseSBzb3J0IG51bWJlcnNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLnJldmVyc2VPcmRlcl0gcmV2ZXJzZSBzb3J0IHRoZSBvcmRlcklkXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wdGlvbnMuYWx3YXlzSW5MaXN0PXRydWVdIHBsYWNlIGVsZW1lbnQgaW5zaWRlIGNsb3Nlc3QgcmVsYXRlZCBTb3J0YWJsZSBvYmplY3Q7IGlmIHNldCB0byBmYWxzZSB0aGVuIHRoZSBvYmplY3QgaXMgcmVtb3ZlZCBpZiBkcm9wcGVkIG91dHNpZGUgcmVsYXRlZCBzb3J0YWJsZXNcclxuICogQHByb3BlcnR5IHtvYmplY3R9IFtvcHRpb25zLmNoaWxkcmVuU3R5bGVzXSBzdHlsZXMgdG8gYXBwbHkgdG8gY2hpbGRyZW4gZWxlbWVudHMgb2YgU29ydGFibGVcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3B0aW9ucy51c2VJY29ucz10cnVlXSBzaG93IGljb25zIHdoZW4gZHJhZ2dpbmdcclxuICogQHByb3BlcnR5IHtvYmplY3R9IFtvcHRpb25zLmljb25zXSBkZWZhdWx0IHNldCBvZiBpY29uc1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbnMuaWNvbnMucmVvcmRlcl1cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLmljb25zLm1vdmVdXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5pY29ucy5jb3B5XVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbnMuaWNvbnMuZGVsZXRlXVxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBuYW1lOiAnc29ydGFibGUnLFxyXG4gICAgc29ydDogdHJ1ZSxcclxuICAgIG9yZGVySWQ6ICdkYXRhLW9yZGVyJyxcclxuICAgIG9yZGVySWRJc051bWJlcjogdHJ1ZSxcclxuICAgIHRocmVzaG9sZDogMTAsXHJcbiAgICBhbHdheXNJbkxpc3Q6IHRydWUsXHJcbiAgICBkcmFnQ2xhc3M6IG51bGwsXHJcbiAgICBvcmRlckNsYXNzOiBudWxsLFxyXG4gICAgcmV0dXJuSG9tZTogdHJ1ZSxcclxuICAgIGRlZXBTZWFyY2g6IGZhbHNlLFxyXG4gICAgZHJhZ1N0eWxlOiB7XHJcbiAgICAgICAgYm94U2hhZG93OiAnM3B4IDNweCA1cHggcmdiYSgwLDAsMCwwLjI1KScsXHJcbiAgICAgICAgb3BhY2l0eTogMC44NVxyXG4gICAgfSxcclxuICAgIGNoaWxkcmVuU3R5bGVzOiB7XHJcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcclxuICAgIH0sXHJcbiAgICB1c2VJY29uczogdHJ1ZSxcclxuICAgIGljb25zXHJcbn0iXX0=